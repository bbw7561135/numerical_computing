\lab{Algoirthms}{Database Essentials}{Database Essentials}
\objective{Familiarization with MySQL prompt and basic queries}
\label{lab:DbEssentials}

\section*{Introduction to MySQL}

Databases are an essential part of computation.  We will learn how to use SQL databases in this section.  SQL is a programming language specification for manipulating relational databases. There are many implementations of SQL, and although they all follow more or less the same syntax, each has it's own keywords.

We will be using the SQLite (version 3) implementation. SQLite is special in that it does not require a background server and is contained in just the commandline client. It may not have all the commands of a full SQL server, but it is still useful in small applications. It is also advantegous to us because now we don't have to set up a server.

Start up SQLite with the following to create a new database called \li{testdb.db} in the current directory.

\begin{lstlisting}[style=ShellInput]
sqlite3 testdb.db
\end{lstlisting}

You should get a new prompt that looks like this

\begin{lstlisting}
SQLite version 3.7.17 2013-05-20 00:56:22
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> 

\end{lstlisting}

\section*{Basic Commands in MySQL}

\subsection{Creating Databases and Tables}

SQLlite can store muliple databases, and each database will have several tables.  To see the databases in SQLlite, we use the {\tt .databases;} command.

\begin{lstlisting}

sqlite> .databases
seq  name             file                                                      
---  ---------------  -------------------
0    main             /home/sqlite/testdb

\end{lstlisting}

All commands that start with a "\li{.}" are commands specific to SQLite. A few other useful commands are \li{.help} (to pull up a list of common commands), \li{.quit} (to quit the client), and \li{.dump} ( to dump the current database into a text file). If you start up the client without specifing a database, you can latter save it to file using \li{.save}.

Now, quit the current client and start up a new one with a new database called \li{students.db}.

\begin{lstlisting}[style=ShellInput]
sqlite3 students.db
\end{lstlisting}

Now we add some tables to the students database. Use the {\tt CREATE} command to create a table and specify the column names of the table.

\begin{lstlisting}

sqlite> CREATE TABLE student_information (StudentID INT NOT NULL, Name VARCHAR(20), SocSecurity INT, MajorCode INT);

\end{lstlisting}

Note that this command ends with a semicolon ";". All SQL commands are terminated by a semicolon.

This creates a student information table with coloumns for each individuals student id, social security number, major, and name.  The arguments in parentheses are the column names followed by the datatype that entries in that column will take.  The {\tt INT} datatype allows up to 32-bit integers and {\tt VARCHAR(20)} allows strings of variable length up to 20 characters.  There are dozens of options to choose from.  The online SQLite documentation is a good resource to explore them and to see which are available in SQLite.

Now we add another table that matches students to classes that they have taken and their grades.

\begin{lstlisting}

sqlite> CREATE TABLE student_classes (StudentID INT NOT NULL, ClassID INT, Grade VARCHAR(2));

\end{lstlisting}

\begin{problem}

In this problem you will create two new tables using the {\tt CREATE TABLE} syntax.  The first table will be called major_information and have two columns called MajorID and MajorName.  MajorID should have the INT datatype and MajorName should be VARCHAR(20).

The second table will be called class_information and have columns called ClassID and ClassName, also INT and VARCHAR(20) respectively.

\end{problem}

\subsection{Inserting Data}

In this section we will insert data into the tables that we have created.  First we will show how to manually add data using the {\tt INSERT} command.  {\tt INSERT} requires that we specify which table that we wish to modify and the values for each column.  For example

\begin{lstlisting}
sqlite> INSERT INTO student_information VALUES(55, "John Smith", 372897382, 2);
\end{lstlisting}

We may also remove the line we just inserted using the {\tt DELETE} command.

\begin{lstlisting}

sqlite> DELETE FROM student_information WHERE StudentID=55;

\end{lstlisting}

These commands are useful for table maintenance or where it may be automated, but MySQL is a very powerful tool for dealing with large amounts of data.  Manually inserting and deleting in such a table is ornerous in even simple cases and essentially impossible for a moderately sized table.  If we have some data in a file on our computer, we may use the \li{.import} command to automatically move it into our database.

\begin{lstlisting}

sqlite> .mode csv
sqlite> .import students.dat student_information

\end{lstlisting}

The \li{.mode} command specifies the file structure. \li{csv} specifies that it's a comma delimited file.

\begin{problem}

Download students.dat, class\_info.dat, classes.dat, and major\_info.dat and use the {\tt .import} command to insert the data in each into student\_information, class_information, student\_classes and major_information respectively.

\end{problem}

\begin{comment}
Unfortunatly sqlite can only time SQL queries
.import isn't one
\begin{problem}

Using python, write a program that will accepts a number of rows and returns a 10 column matrix with the specified number of rows and write it to a file with each column separated by commas.  The first column should be in ascending numeric order, but the others should have random numbers in them.  Generate matrices with 100, 1000, 10000, and 100000 rows.  Load each into a different table in a new database and time the load operation.  How does the time increase?

\end{problem}
\end{comment}

\section{Querying and Joining Tables}

Now that we have loaded data in the form of our student database we will learn to query and join the tables.  The first command that we will use is {\tt SELECT}, which returns specified rows of a table.  For example

\begin{lstlisting}
sqlite> SELECT Name FROM student_information;
" Donald Chamberlin"
" Raymond Boyce"
" D.Richard Hipp"
" Jeff Humphreys"
" Travis Oliphant"
" Tyler Jarvis"
" Randall Munroe"
" Janice Joplin"
" John Lennon"
" Tupac Shakur"
\end{lstlisting}

After {\tt SELECT} we specify a column and a table to query, and SQLite returns the requested rows.  We may also add conditions to our command to get more refined results.

\begin{lstlisting}
sqlite> SELECT Name FROM student_information WHERE StudentID = 4;
" Jeff Humphreys"
\end{lstlisting}

Or we may select more than one column

\begin{lstlisting}

sqlite> SELECT Name, SocSecurity FROM student_information WHERE StudentID = 4;
" Jeff Humphreys",736452198

sqlite> SELECT * FROM student_information WHERE StudentID = 4;
4," Jeff Humphreys",736452198,3

sqlite> SELECT * FROM student_information;
1," Donald Chamberlin",123456789,1
2," Raymond Boyce",987654321,1
3," D.Richard Hipp",431256789,2
4," Jeff Humphreys",736452198,3
5," Travis Oliphant",172645382,4
6," Tyler Jarvis",174382645,3
7," Randall Munroe",827635142,2
8," Janice Joplin",987263512,1
9," John Lennon",192837641,3
10," Tupac Shakur",192837412,2

\end{lstlisting}

We may join tables by columns using the {\tt INNER JOIN} command.  This is a very powerful tool for uniting data across many tables.  In SQLite we can use {\tt INNER JOIN} in conjunction with {\tt SELECT} to query data across many tables into place.  For example we can inner join student\_classes and student\_information on the StudentID column to display student information and grades in one table.

\begin{lstlisting}

sqlite> SELECT * FROM student_information INNER JOIN student_classes ON student_information.StudentID = student_classes.StudentID;
1," Donald Chamberlin",123456789,1,1,3," B-"
1," Donald Chamberlin",123456789,1,1,4," C"
2," Raymond Boyce",987654321,1,2,1," B"
2," Raymond Boyce",987654321,1,2,3," A+"
2," Raymond Boyce",987654321,1,2,4," A+"
3," D.Richard Hipp",431256789,2,3,2," C"
4," Jeff Humphreys",736452198,3,4,1," A"
5," Travis Oliphant",172645382,4,5,2," C"
5," Travis Oliphant",172645382,4,5,3," C-"
5," Travis Oliphant",172645382,4,5,4," A"
6," Tyler Jarvis",174382645,3,6,1," B"
6," Tyler Jarvis",174382645,3,6,2," A+"
6," Tyler Jarvis",174382645,3,6,4," D"
7," Randall Munroe",827635142,2,7,1," C+"
7," Randall Munroe",827635142,2,7,2," A"
8," Janice Joplin",987263512,1,8,1," A-"
8," Janice Joplin",987263512,1,8,2," D-"
9," John Lennon",192837641,3,9,2," B"
9," John Lennon",192837641,3,9,3," C"
10," Tupac Shakur",192837412,2,10,1," A"
10," Tupac Shakur",192837412,2,10,2," A-"


\end{lstlisting}

By specify columns, we can display the grades of one student.

\begin{lstlisting}

sqlite> SELECT Name, Grade FROM student_information INNER JOIN student_classes ON student_information.StudentID = student_classes.StudentID WHERE student_information.StudentID=6;
" Tyler Jarvis"," A+"
" Tyler Jarvis"," B"
" Tyler Jarvis"," D"

\end{lstlisting}

\begin{problem}

Use {\tt INNER JOIN} and {\tt SELECT} to display the student\_information table, but show the students majors and classes instead of ClassID and MajorID.

\end{problem}

